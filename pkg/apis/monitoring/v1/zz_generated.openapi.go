// +build !ignore_autogenerated

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"./pkg/apis/monitoring/v1.APIServerConfig":      schema_pkg_apis_monitoring_v1_APIServerConfig(ref),
		"./pkg/apis/monitoring/v1.Alertmanager":         schema_pkg_apis_monitoring_v1_Alertmanager(ref),
		"./pkg/apis/monitoring/v1.AlertmanagerList":     schema_pkg_apis_monitoring_v1_AlertmanagerList(ref),
		"./pkg/apis/monitoring/v1.AlertmanagerSpec":     schema_pkg_apis_monitoring_v1_AlertmanagerSpec(ref),
		"./pkg/apis/monitoring/v1.AlertmanagerStatus":   schema_pkg_apis_monitoring_v1_AlertmanagerStatus(ref),
		"./pkg/apis/monitoring/v1.BasicAuth":            schema_pkg_apis_monitoring_v1_BasicAuth(ref),
		"./pkg/apis/monitoring/v1.Endpoint":             schema_pkg_apis_monitoring_v1_Endpoint(ref),
		"./pkg/apis/monitoring/v1.NamespaceSelector":    schema_pkg_apis_monitoring_v1_NamespaceSelector(ref),
		"./pkg/apis/monitoring/v1.PrometheusRule":       schema_pkg_apis_monitoring_v1_PrometheusRule(ref),
		"./pkg/apis/monitoring/v1.PrometheusRuleList":   schema_pkg_apis_monitoring_v1_PrometheusRuleList(ref),
		"./pkg/apis/monitoring/v1.PrometheusRuleSpec":   schema_pkg_apis_monitoring_v1_PrometheusRuleSpec(ref),
		"./pkg/apis/monitoring/v1.QueueConfig":          schema_pkg_apis_monitoring_v1_QueueConfig(ref),
		"./pkg/apis/monitoring/v1.RelabelConfig":        schema_pkg_apis_monitoring_v1_RelabelConfig(ref),
		"./pkg/apis/monitoring/v1.RemoteWriteSpec":      schema_pkg_apis_monitoring_v1_RemoteWriteSpec(ref),
		"./pkg/apis/monitoring/v1.Rule":                 schema_pkg_apis_monitoring_v1_Rule(ref),
		"./pkg/apis/monitoring/v1.RuleGroup":            schema_pkg_apis_monitoring_v1_RuleGroup(ref),
		"./pkg/apis/monitoring/v1.ServiceMonitor":       schema_pkg_apis_monitoring_v1_ServiceMonitor(ref),
		"./pkg/apis/monitoring/v1.ServiceMonitorSpec":   schema_pkg_apis_monitoring_v1_ServiceMonitorSpec(ref),
		"./pkg/apis/monitoring/v1.ServiceMonitorStatus": schema_pkg_apis_monitoring_v1_ServiceMonitorStatus(ref),
		"./pkg/apis/monitoring/v1.StorageSpec":          schema_pkg_apis_monitoring_v1_StorageSpec(ref),
		"./pkg/apis/monitoring/v1.TLSConfig":            schema_pkg_apis_monitoring_v1_TLSConfig(ref),
	}
}

func schema_pkg_apis_monitoring_v1_APIServerConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIServerConfig defines a host and auth methods to access apiserver. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"host": {
						SchemaProps: spec.SchemaProps{
							Description: "Host of apiserver. A valid string consisting of a hostname or IP followed by an optional port number",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"basicAuth": {
						SchemaProps: spec.SchemaProps{
							Description: "BasicAuth allow an endpoint to authenticate over basic authentication",
							Ref:         ref("./pkg/apis/monitoring/v1.BasicAuth"),
						},
					},
					"bearerToken": {
						SchemaProps: spec.SchemaProps{
							Description: "Bearer token for accessing apiserver.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"bearerTokenFile": {
						SchemaProps: spec.SchemaProps{
							Description: "File to read bearer token for accessing apiserver.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tlsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS Config to use for accessing apiserver.",
							Ref:         ref("./pkg/apis/monitoring/v1.TLSConfig"),
						},
					},
				},
				Required: []string{"host"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.BasicAuth", "./pkg/apis/monitoring/v1.TLSConfig"},
	}
}

func schema_pkg_apis_monitoring_v1_Alertmanager(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Alertmanager describes an Alertmanager cluster.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Ref:         ref("./pkg/apis/monitoring/v1.AlertmanagerSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Most recent observed status of the Alertmanager cluster. Read-only. Not included when requesting from the apiserver, only from the Prometheus Operator API itself. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Ref:         ref("./pkg/apis/monitoring/v1.AlertmanagerStatus"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.AlertmanagerSpec", "./pkg/apis/monitoring/v1.AlertmanagerStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1_AlertmanagerList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AlertmanagerList is a list of Alertmanagers.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of Alertmanagers",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.Alertmanager"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.Alertmanager", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_monitoring_v1_AlertmanagerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AlertmanagerSpec is a specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.",
							Ref:         ref("./pkg/apis/monitoring/v1.EmbeddedObjectMetadata"),
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version the cluster should be on.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "Tag of Alertmanager container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"sha": {
						SchemaProps: spec.SchemaProps{
							Description: "SHA of Alertmanager container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"baseImage": {
						SchemaProps: spec.SchemaProps{
							Description: "Base image that is used to deploy pods, without tag.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"secrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configMaps": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains configuration for this Alertmanager instance. Defaults to 'alertmanager-<alertmanager-name>' The secret is mounted into /etc/alertmanager/config.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "Log level for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logFormat": {
						SchemaProps: spec.SchemaProps{
							Description: "Log format for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"retention": {
						SchemaProps: spec.SchemaProps{
							Description: "Time duration Alertmanager shall retain data for. Default is '120h', and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storage": {
						SchemaProps: spec.SchemaProps{
							Description: "Storage is the definition of how storage will be used by the Alertmanager instances.",
							Ref:         ref("./pkg/apis/monitoring/v1.StorageSpec"),
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container, that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"externalURL": {
						SchemaProps: spec.SchemaProps{
							Description: "The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"routePrefix": {
						SchemaProps: spec.SchemaProps{
							Description: "The route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "If set to true all actions on the underlaying managed objects are not goint to be performed, except for delete actions.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Define which Nodes the Pods are scheduled on.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Define resources requests and limits for single Pods.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints.",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"listenLocal": {
						SchemaProps: spec.SchemaProps{
							Description: "ListenLocal makes the Alertmanager server listen on loopback, so that it does not bind against the Pod IP. Note this is only for the Alertmanager UI, not the gossip communication.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Alertmanager configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other then secret fetching is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority class assigned to the Pods",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"additionalPeers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"clusterAdvertiseAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "ClusterAdvertiseAddress is the explicit address to advertise in cluster. Needs to be provided for non RFC1918 [1] (public) addresses. [1] RFC1918: https://tools.ietf.org/html/rfc1918",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"portName": {
						SchemaProps: spec.SchemaProps{
							Description: "Port name used for the pods and governing service. This defaults to web",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.EmbeddedObjectMetadata", "./pkg/apis/monitoring/v1.StorageSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_monitoring_v1_AlertmanagerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AlertmanagerStatus is the most recent observed status of the Alertmanager cluster. Read-only. Not included when requesting from the apiserver, only from the Prometheus Operator API itself. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents whether any actions on the underlaying managed objects are being performed. Only delete actions will be performed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of non-terminated pods targeted by this Alertmanager cluster (their labels match the selector).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of non-terminated pods targeted by this Alertmanager cluster that have the desired version spec.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of available pods (ready for at least minReadySeconds) targeted by this Alertmanager cluster.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"unavailableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of unavailable pods targeted by this Alertmanager cluster.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"paused", "replicas", "updatedReplicas", "availableReplicas", "unavailableReplicas"},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1_BasicAuth(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "The secret in the service monitor namespace that contains the username for authentication.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "The secret in the service monitor namespace that contains the password for authentication.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_monitoring_v1_Endpoint(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Endpoint defines a scrapeable endpoint serving Prometheus metrics.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the service port this endpoint refers to. Mutually exclusive with targetPort.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"targetPort": {
						SchemaProps: spec.SchemaProps{
							Description: "Name or number of the pod port this endpoint refers to. Mutually exclusive with port.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP path to scrape for metrics.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scheme": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP scheme to use for scraping.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"params": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional HTTP URL parameters",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Type:   []string{"string"},
													Format: "",
												},
											},
										},
									},
								},
							},
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Description: "Interval at which metrics should be scraped",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scrapeTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout after which the scrape is ended",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tlsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration to use when scraping the endpoint",
							Ref:         ref("./pkg/apis/monitoring/v1.TLSConfig"),
						},
					},
					"bearerTokenFile": {
						SchemaProps: spec.SchemaProps{
							Description: "File to read bearer token for scraping targets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"bearerTokenSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"honorLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "HonorLabels chooses the metric's labels on collisions with target labels.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"honorTimestamps": {
						SchemaProps: spec.SchemaProps{
							Description: "HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"basicAuth": {
						SchemaProps: spec.SchemaProps{
							Description: "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
							Ref:         ref("./pkg/apis/monitoring/v1.BasicAuth"),
						},
					},
					"metricRelabelConfigs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "MetricRelabelConfigs to apply to samples before ingestion.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.RelabelConfig"),
									},
								},
							},
						},
					},
					"relabelConfigs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RelabelConfigs to apply to samples before scraping. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.RelabelConfig"),
									},
								},
							},
						},
					},
					"proxyURL": {
						SchemaProps: spec.SchemaProps{
							Description: "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.BasicAuth", "./pkg/apis/monitoring/v1.RelabelConfig", "./pkg/apis/monitoring/v1.TLSConfig", "k8s.io/api/core/v1.SecretKeySelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_monitoring_v1_NamespaceSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NamespaceSelector is a selector for selecting either all namespaces or a list of namespaces.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"any": {
						SchemaProps: spec.SchemaProps{
							Description: "Boolean describing whether all namespaces are selected in contrast to a list restricting them.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"matchNames": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of namespace names.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1_PrometheusRule(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PrometheusRule defines alerting rules for a Prometheus instance",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of desired alerting rule definitions for Prometheus.",
							Ref:         ref("./pkg/apis/monitoring/v1.PrometheusRuleSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.PrometheusRuleSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1_PrometheusRuleList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PrometheusRuleList is a list of PrometheusRules.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of Rules",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.PrometheusRule"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.PrometheusRule", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_monitoring_v1_PrometheusRuleSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PrometheusRuleSpec contains specification parameters for a Rule.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"groups": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Content of Prometheus rule file",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.RuleGroup"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.RuleGroup"},
	}
}

func schema_pkg_apis_monitoring_v1_QueueConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "QueueConfig allows the tuning of remote_write queue_config parameters. This object is referenced in the RemoteWriteSpec object.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"capacity": {
						SchemaProps: spec.SchemaProps{
							Description: "Capacity is the number of samples to buffer per shard before we start dropping them.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"minShards": {
						SchemaProps: spec.SchemaProps{
							Description: "MinShards is the minimum number of shards, i.e. amount of concurrency.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxShards": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxShards is the maximum number of shards, i.e. amount of concurrency.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxSamplesPerSend": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxSamplesPerSend is the maximum number of samples per send.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"batchSendDeadline": {
						SchemaProps: spec.SchemaProps{
							Description: "BatchSendDeadline is the maximum time a sample will wait in buffer.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxRetries": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxRetries is the maximum number of times to retry a batch on recoverable errors.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"minBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "MinBackoff is the initial retry delay. Gets doubled for every retry.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxBackoff is the maximum retry delay.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1_RelabelConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"sourceLabels": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"separator": {
						SchemaProps: spec.SchemaProps{
							Description: "Separator placed between concatenated source label values. default is ';'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"targetLabel": {
						SchemaProps: spec.SchemaProps{
							Description: "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"regex": {
						SchemaProps: spec.SchemaProps{
							Description: "Regular expression against which the extracted value is matched. Default is '(.*)'",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modulus": {
						SchemaProps: spec.SchemaProps{
							Description: "Modulus to take of the hash of the source label values.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replacement": {
						SchemaProps: spec.SchemaProps{
							Description: "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"action": {
						SchemaProps: spec.SchemaProps{
							Description: "Action to perform based on regex matching. Default is 'replace'",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1_RemoteWriteSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RemoteWriteSpec defines the remote_write configuration for prometheus.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "The URL of the endpoint to send samples to.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of the remote write queue, must be unique if specified. The name is used in metrics and logging in order to differentiate queues. Only valid in Prometheus versions 2.15.0 and newer.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"remoteTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout for requests to the remote write endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"writeRelabelConfigs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "The list of remote write relabel configurations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.RelabelConfig"),
									},
								},
							},
						},
					},
					"basicAuth": {
						SchemaProps: spec.SchemaProps{
							Description: "BasicAuth for the URL.",
							Ref:         ref("./pkg/apis/monitoring/v1.BasicAuth"),
						},
					},
					"bearerToken": {
						SchemaProps: spec.SchemaProps{
							Description: "File to read bearer token for remote write.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"bearerTokenFile": {
						SchemaProps: spec.SchemaProps{
							Description: "File to read bearer token for remote write.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tlsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS Config to use for remote write.",
							Ref:         ref("./pkg/apis/monitoring/v1.TLSConfig"),
						},
					},
					"proxyURL": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional ProxyURL",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"queueConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "QueueConfig allows tuning of the remote write queue parameters.",
							Ref:         ref("./pkg/apis/monitoring/v1.QueueConfig"),
						},
					},
				},
				Required: []string{"url"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.BasicAuth", "./pkg/apis/monitoring/v1.QueueConfig", "./pkg/apis/monitoring/v1.RelabelConfig", "./pkg/apis/monitoring/v1.TLSConfig"},
	}
}

func schema_pkg_apis_monitoring_v1_Rule(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Rule describes an alerting or recording rule.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"record": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"alert": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"expr": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"for": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
				Required: []string{"expr"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_monitoring_v1_RuleGroup(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RuleGroup is a list of sequentially evaluated recording and alerting rules. Note: PartialResponseStrategy is only used by ThanosRuler and will be ignored by Prometheus instances.  Valid values for this field are 'warn' or 'abort'.  More info: https://github.com/thanos-io/thanos/blob/master/docs/components/rule.md#partial-response",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"rules": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.Rule"),
									},
								},
							},
						},
					},
					"partialResponseStrategy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"name", "rules"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.Rule"},
	}
}

func schema_pkg_apis_monitoring_v1_ServiceMonitor(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceMonitor is the Schema for the servicemonitors API ServiceMonitor defines monitoring for a set of services.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of desired Service selection for target discovery by Prometheus.",
							Ref:         ref("./pkg/apis/monitoring/v1.ServiceMonitorSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.ServiceMonitorSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1_ServiceMonitorSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceMonitorSpec contains specification parameters for a ServiceMonitor.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"jobLabel": {
						SchemaProps: spec.SchemaProps{
							Description: "The label to use to retrieve the job name from.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"targetLabels": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TargetLabels transfers labels on the Kubernetes Service onto the target.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"podTargetLabels": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "PodTargetLabels transfers labels on the Kubernetes Pod onto the target.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"endpoints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "A list of endpoints allowed as part of this ServiceMonitor.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1.Endpoint"),
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector to select Endpoints objects.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"namespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector to select which namespaces the Endpoints objects are discovered from.",
							Ref:         ref("./pkg/apis/monitoring/v1.NamespaceSelector"),
						},
					},
					"sampleLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"endpoints", "selector"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.Endpoint", "./pkg/apis/monitoring/v1.NamespaceSelector", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_monitoring_v1_ServiceMonitorStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceMonitorStatus defines the observed state of ServiceMonitor",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1_StorageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageSpec defines the configured storage for a group Prometheus servers. If neither `emptyDir` nor `volumeClaimTemplate` is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"disableMountSubPath": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary. DisableMountSubPath allows to remove any subPath usage in volume mounts.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"emptyDir": {
						SchemaProps: spec.SchemaProps{
							Description: "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",
							Ref:         ref("k8s.io/api/core/v1.EmptyDirVolumeSource"),
						},
					},
					"volumeClaimTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "A PVC spec to be used by the Prometheus StatefulSets.",
							Ref:         ref("./pkg/apis/monitoring/v1.EmbeddedPersistentVolumeClaim"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.EmbeddedPersistentVolumeClaim", "k8s.io/api/core/v1.EmptyDirVolumeSource"},
	}
}

func schema_pkg_apis_monitoring_v1_TLSConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TLSConfig specifies TLS configuration parameters.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"caFile": {
						SchemaProps: spec.SchemaProps{
							Description: "Path to the CA cert in the Prometheus container to use for the targets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ca": {
						SchemaProps: spec.SchemaProps{
							Description: "Stuct containing the CA cert to use for the targets.",
							Ref:         ref("./pkg/apis/monitoring/v1.SecretOrConfigMap"),
						},
					},
					"certFile": {
						SchemaProps: spec.SchemaProps{
							Description: "Path to the client cert file in the Prometheus container for the targets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"cert": {
						SchemaProps: spec.SchemaProps{
							Description: "Struct containing the client cert file for the targets.",
							Ref:         ref("./pkg/apis/monitoring/v1.SecretOrConfigMap"),
						},
					},
					"keyFile": {
						SchemaProps: spec.SchemaProps{
							Description: "Path to the client key file in the Prometheus container for the targets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keySecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Secret containing the client key file for the targets.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"serverName": {
						SchemaProps: spec.SchemaProps{
							Description: "Used to verify the hostname for the targets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"insecureSkipVerify": {
						SchemaProps: spec.SchemaProps{
							Description: "Disable target certificate validation.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1.SecretOrConfigMap", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}
