// +build !ignore_autogenerated

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1beta1

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"./pkg/apis/monitoring/v1beta1.PodMetricsEndpoint": schema_pkg_apis_monitoring_v1beta1_PodMetricsEndpoint(ref),
		"./pkg/apis/monitoring/v1beta1.PodMonitor":         schema_pkg_apis_monitoring_v1beta1_PodMonitor(ref),
		"./pkg/apis/monitoring/v1beta1.PodMonitorSpec":     schema_pkg_apis_monitoring_v1beta1_PodMonitorSpec(ref),
		"./pkg/apis/monitoring/v1beta1.StorageSpec":        schema_pkg_apis_monitoring_v1beta1_StorageSpec(ref),
		"./pkg/apis/monitoring/v1beta1.VmAgent":            schema_pkg_apis_monitoring_v1beta1_VmAgent(ref),
		"./pkg/apis/monitoring/v1beta1.VmAgentSpec":        schema_pkg_apis_monitoring_v1beta1_VmAgentSpec(ref),
		"./pkg/apis/monitoring/v1beta1.VmAgentStatus":      schema_pkg_apis_monitoring_v1beta1_VmAgentStatus(ref),
		"./pkg/apis/monitoring/v1beta1.VmAlert":            schema_pkg_apis_monitoring_v1beta1_VmAlert(ref),
		"./pkg/apis/monitoring/v1beta1.VmAlertSpec":        schema_pkg_apis_monitoring_v1beta1_VmAlertSpec(ref),
		"./pkg/apis/monitoring/v1beta1.VmAlertStatus":      schema_pkg_apis_monitoring_v1beta1_VmAlertStatus(ref),
		"./pkg/apis/monitoring/v1beta1.VmSingle":           schema_pkg_apis_monitoring_v1beta1_VmSingle(ref),
		"./pkg/apis/monitoring/v1beta1.VmSingleSpec":       schema_pkg_apis_monitoring_v1beta1_VmSingleSpec(ref),
		"./pkg/apis/monitoring/v1beta1.VmSingleStatus":     schema_pkg_apis_monitoring_v1beta1_VmSingleStatus(ref),
	}
}

func schema_pkg_apis_monitoring_v1beta1_PodMetricsEndpoint(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodMetricsEndpoint defines a scrapeable endpoint of a Kubernetes Pod serving Prometheus metrics.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the pod port this endpoint refers to. Mutually exclusive with targetPort.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"targetPort": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: Use 'port' instead.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP path to scrape for metrics.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scheme": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP scheme to use for scraping.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"params": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional HTTP URL parameters",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Type:   []string{"string"},
													Format: "",
												},
											},
										},
									},
								},
							},
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Description: "Interval at which metrics should be scraped",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scrapeTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout after which the scrape is ended",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"honorLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "HonorLabels chooses the metric's labels on collisions with target labels.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"honorTimestamps": {
						SchemaProps: spec.SchemaProps{
							Description: "HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metricRelabelConfigs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "MetricRelabelConfigs to apply to samples before ingestion.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.RelabelConfig"),
									},
								},
							},
						},
					},
					"relabelConfigs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RelabelConfigs to apply to samples before ingestion. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.RelabelConfig"),
									},
								},
							},
						},
					},
					"proxyURL": {
						SchemaProps: spec.SchemaProps{
							Description: "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.RelabelConfig", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_PodMonitor(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodMonitor defines monitoring for a set of pods.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of desired Pod selection for target discovery by Prometheus.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.PodMonitorSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.PodMonitorSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_PodMonitorSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodMonitorSpec contains specification parameters for a PodMonitor.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"jobLabel": {
						SchemaProps: spec.SchemaProps{
							Description: "The label to use to retrieve the job name from.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podTargetLabels": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "PodTargetLabels transfers labels on the Kubernetes Pod onto the target.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"podMetricsEndpoints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "A list of endpoints allowed as part of this PodMonitor.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/monitoring/v1beta1.PodMetricsEndpoint"),
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector to select Pod objects.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"namespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector to select which namespaces the Endpoints objects are discovered from.",
							Ref:         ref("github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.NamespaceSelector"),
						},
					},
					"sampleLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"podMetricsEndpoints", "selector"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.PodMetricsEndpoint", "github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.NamespaceSelector", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_StorageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageSpec defines the configured storage for a group Prometheus servers. If neither `emptyDir` nor `volumeClaimTemplate` is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"disableMountSubPath": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary. DisableMountSubPath allows to remove any subPath usage in volume mounts.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"emptyDir": {
						SchemaProps: spec.SchemaProps{
							Description: "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",
							Ref:         ref("k8s.io/api/core/v1.EmptyDirVolumeSource"),
						},
					},
					"volumeClaimTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "A PVC spec to be used by the Prometheus StatefulSets.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.EmbeddedPersistentVolumeClaim"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.EmbeddedPersistentVolumeClaim", "k8s.io/api/core/v1.EmptyDirVolumeSource"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAgent(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAgent is the Schema for the vmagents API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmAgentSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmAgentStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.VmAgentSpec", "./pkg/apis/monitoring/v1beta1.VmAgentStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAgentSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAgentSpec defines the desired state of VmAgent",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run \"operator-sdk generate k8s\" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.EmbeddedObjectMetadata"),
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version the cluster should be on.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"secrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configMaps": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains configuration for this Alertmanager instance. Defaults to 'alertmanager-<alertmanager-name>' The secret is mounted into /etc/alertmanager/config.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "Log level for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logFormat": {
						SchemaProps: spec.SchemaProps{
							Description: "Log format for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected size.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"storage": {
						SchemaProps: spec.SchemaProps{
							Description: "Storage is the definition of how storage will be used by the Alertmanager instances.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.StorageSpec"),
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container, that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Define resources requests and limits for single Pods.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints.",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Alertmanager configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other then secret fetching is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority class assigned to the Pods",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"additionalPeers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"clusterAdvertiseAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "ClusterAdvertiseAddress is the explicit address to advertise in cluster. Needs to be provided for non RFC1918 [1] (public) addresses. [1] RFC1918: https://tools.ietf.org/html/rfc1918",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"portName": {
						SchemaProps: spec.SchemaProps{
							Description: "Port name used for the pods and governing service. This defaults to web",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scrapeInterval": {
						SchemaProps: spec.SchemaProps{
							Description: "how often scrape by default",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"aPIServerConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "APIServerConfig allows specifying a host and auth methods to access apiserver. If left empty, Prometheus is assumed to run inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.",
							Ref:         ref("github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.APIServerConfig"),
						},
					},
					"overrideHonorLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "OverrideHonorLabels if set to true overrides all user configured honor_labels. If HonorLabels is set in ServiceMonitor or PodMonitor to true, this overrides honor_labels to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"overrideHonorTimestamps": {
						SchemaProps: spec.SchemaProps{
							Description: "OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"ignoreNamespaceSelectors": {
						SchemaProps: spec.SchemaProps{
							Description: "IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from the podmonitor and servicemonitor configs, and they will only discover endpoints within their current namespace.  Defaults to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"enforcedNamespaceLabel": {
						SchemaProps: spec.SchemaProps{
							Description: "EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert and metric that is user created. The label value will always be the namespace of the object that is being created.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicaExternalLabelName": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of Prometheus external label used to denote replica name. Defaults to the value of `prometheus_replica`. External label will _not_ be added when value is set to empty string (`\"\"`).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"remoteWrite": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the remote_write spec. This is an experimental feature, it may change in any upcoming release in a breaking way.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.RemoteWriteSpec"),
									},
								},
							},
						},
					},
					"serviceMonitorSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceMonitors to be selected for target discovery. *Deprecated:* if neither this nor podMonitorSelector are specified, configuration is unmanaged.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"serviceMonitorNamespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespaces to be selected for ServiceMonitor discovery. If nil, only check own namespace.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"podMonitorSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "*Experimental* PodMonitors to be selected for target discovery. *Deprecated:* if neither this nor serviceMonitorSelector are specified, configuration is unmanaged.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"podMonitorNamespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespaces to be selected for PodMonitor discovery. If nil, only check own namespace.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"additionalScrapeConfigs": {
						SchemaProps: spec.SchemaProps{
							Description: "As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"arbitraryFSAccessThroughSMs": {
						SchemaProps: spec.SchemaProps{
							Description: "ArbitraryFSAccessThroughSMs configures whether configuration based on a service monitor can access arbitrary files on the file system of the Prometheus container e.g. bearer token files.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.ArbitraryFSAccessThroughSMsConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.ArbitraryFSAccessThroughSMsConfig", "./pkg/apis/monitoring/v1beta1.EmbeddedObjectMetadata", "./pkg/apis/monitoring/v1beta1.StorageSpec", "github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.APIServerConfig", "github.com/VictoriaMetrics/operator/pkg/apis/monitoring/v1.RemoteWriteSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecretKeySelector", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAgentStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAgentStatus defines the observed state of VmAgent",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAlert(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAlert is the Schema for the vmalerts API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmAlertSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmAlertStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.VmAlertSpec", "./pkg/apis/monitoring/v1beta1.VmAlertStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAlertSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAlertSpec defines the desired state of VmAlert",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run \"operator-sdk generate k8s\" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.",
							Ref:         ref("./pkg/apis/monitoring/v1beta1.EmbeddedObjectMetadata"),
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version the cluster should be on.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"secrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configMaps": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"configSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains configuration for this Alertmanager instance. Defaults to 'alertmanager-<alertmanager-name>' The secret is mounted into /etc/alertmanager/config.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "Log level for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logFormat": {
						SchemaProps: spec.SchemaProps{
							Description: "Log format for Alertmanager to be configured with.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected size.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container, that are generated as a result of StorageSpec objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"routePrefix": {
						SchemaProps: spec.SchemaProps{
							Description: "The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name.\n\tExternalURL string `json:\"externalUrl,omitempty\"`\nThe route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "If set to true all actions on the underlaying managed objects are not goint to be performed, except for delete actions.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Define which Nodes the Pods are scheduled on.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Define resources requests and limits for single Pods.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints.",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Alertmanager configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other then secret fetching is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority class assigned to the Pods",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"additionalPeers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"evaluationInterval": {
						SchemaProps: spec.SchemaProps{
							Description: "how often evalute rules",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"additionalAlertRelabelConfigs": {
						SchemaProps: spec.SchemaProps{
							Description: "https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs. As alert relabel configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible alert relabel configs are going to break Prometheus after the upgrade.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"additionalAlertManagerConfigs": {
						SchemaProps: spec.SchemaProps{
							Description: "AdditionalAlertManagerConfigs allows specifying a key of a Secret containing additional Prometheus AlertManager configurations. AlertManager configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config. As AlertManager configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible AlertManager configs are going to break Prometheus after the upgrade.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"ignoreNamespaceSelectors": {
						SchemaProps: spec.SchemaProps{
							Description: "IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from the podmonitor and servicemonitor configs, and they will only discover endpoints within their current namespace.  Defaults to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"enforcedNamespaceLabel": {
						SchemaProps: spec.SchemaProps{
							Description: "EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert and metric that is user created. The label value will always be the namespace of the object that is being created.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ruleSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "A selector to select which PrometheusRules to mount for loading alerting/recording rules from. Until (excluding) Prometheus Operator v0.24.0 Prometheus Operator will migrate any legacy rule ConfigMaps to PrometheusRule custom resources selected by RuleSelector. Make sure it does not match any config maps that you do not want to be migrated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"ruleNamespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespaces to be selected for PrometheusRules discovery. If unspecified, only the same namespace as the Prometheus object is in is used.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.EmbeddedObjectMetadata", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecretKeySelector", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmAlertStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmAlertStatus defines the observed state of VmAlert",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmSingle(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmSingle is the Schema for the vmsingles API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmSingleSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/monitoring/v1beta1.VmSingleStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/monitoring/v1beta1.VmSingleSpec", "./pkg/apis/monitoring/v1beta1.VmSingleStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmSingleSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmSingleSpec defines the desired state of VmSingle",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_monitoring_v1beta1_VmSingleStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VmSingleStatus defines the observed state of VmSingle",
				Type:        []string{"object"},
			},
		},
	}
}
